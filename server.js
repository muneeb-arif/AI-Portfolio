require('dotenv').config();
const express = require('express');
const fs = require('fs');
const path = require('path');
const cors = require('cors');
const OpenAI = require('openai');

// Import existing functionality
const {
  sanitizeFolderName,
  validateUrls,
  getInternalLinksAPI,
  takeScreenshotAPI,
  analyzeHomepageScreenshotAPI,
  findHomepageScreenshot,
  DEFAULT_CONFIG
} = require('./screenshot-api');

// Import Figma functionality
const figmaCapture = require('./figma-api-capture');
const appStoreExtractor = require('./app-info-extractor');

const app = express();
app.use(express.json());
app.use(cors());

// Initialize OpenAI
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY
});

// Utility functions
function getRandomDelay() {
  return Math.floor(Math.random() * (10000 - 5000 + 1)) + 5000; // 5-10 seconds
}

function extractProjectName(url, type) {
  try {
    const urlObj = new URL(url);
    
    switch (type) {
      case 'figma':
        // Extract from Figma URL: figma.com/file/KEY/NAME
        const figmaMatch = url.match(/figma\.com\/(?:file|proto|design)\/[^\/]+\/([^\/\?]+)/);
        return figmaMatch ? figmaMatch[1].replace(/[^\w]/g, '_') : 'figma_project';
      
      case 'stores':
        // Extract from app store URLs
        if (url.includes('play.google.com')) {
          const playMatch = url.match(/id=([\w\.]+)/);
          return playMatch ? `playstore_${playMatch[1]}` : 'playstore_app';
        } else if (url.includes('apps.apple.com')) {
          const appleMatch = url.match(/id(\d+)/);
          return appleMatch ? `appstore_${appleMatch[1]}` : 'appstore_app';
        }
        return 'store_app';
      
      case 'web':
      default:
        // Extract domain name for web URLs
        let domain = urlObj.hostname.replace(/^www\./, '');
        domain = domain.replace(/\.[a-z]{2,}.*$/, '');
        return domain.replace(/[^\w]/g, '_');
    }
  } catch (error) {
    return 'unknown_project';
  }
}

async function analyzeUrlWithOpenAI(url, type) {
  if (!process.env.OPENAI_API_KEY) {
    throw new Error('OpenAI API key not configured');
  }

  const prompt = `Analyze this ${type} URL: ${url}

Please provide a comprehensive analysis in the following format:

SHORT DESCRIPTION:
[Provide a concise 2-line description of what this ${type} URL represents]

DETAILED DESCRIPTION:
[Provide 5-10 detailed paragraphs covering:
- Purpose and functionality
- Target audience
- Key features and capabilities
- Design and user experience
- Business model (if applicable)
- Technical implementation
- Market positioning
- Unique selling points
- User engagement strategies
- Overall quality assessment]

KEY FEATURES:
[List 5-10 key features in bullet points]

TECH STACK:
[Identify the technologies, frameworks, platforms, and tools used]`;

  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4",
      messages: [
        {
          role: "user",
          content: prompt
        }
      ],
      max_tokens: 2000,
      temperature: 0.7
    });

    return response.choices[0].message.content;
  } catch (error) {
    console.error('OpenAI analysis error:', error);
    throw new Error(`Failed to analyze URL: ${error.message}`);
  }
}

async function saveAnalysisToFile(analysis, url, projectName, type) {
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  const analysisDir = path.join(__dirname, 'screenshots', type, projectName);
  
  if (!fs.existsSync(analysisDir)) {
    fs.mkdirSync(analysisDir, { recursive: true });
  }

  const analysisFile = path.join(analysisDir, `analysis_${timestamp}.txt`);
  const content = `URL: ${url}
Type: ${type}
Project: ${projectName}
Analyzed: ${new Date().toISOString()}

${analysis}

---
Generated by Portfolio Screenshot Tool API
`;

  fs.writeFileSync(analysisFile, content);
  return analysisFile;
}

// API 1: Web URLs Screenshot API
app.post('/api/web-screenshots', async (req, res) => {
  try {
    const { urls, analyze = false, deep_capture = false, capture = true } = req.body;

    if (!urls || !Array.isArray(urls) || urls.length === 0) {
      return res.status(400).json({ error: 'URLs array is required and must not be empty' });
    }

    const results = [];
    const puppeteer = require("puppeteer-extra");
    const StealthPlugin = require("puppeteer-extra-plugin-stealth");
    puppeteer.use(StealthPlugin());

    const browser = await puppeteer.launch({ headless: "new" });

    try {
      for (let i = 0; i < urls.length; i++) {
        const url = urls[i];
        console.log(`üåê Processing web URL ${i + 1}/${urls.length}: ${url}`);

        const projectName = extractProjectName(url, 'web');
        const outputDir = path.join(__dirname, 'screenshots', 'web', projectName);
        
        if (!fs.existsSync(outputDir)) {
          fs.mkdirSync(outputDir, { recursive: true });
        }

        // Get internal links if deep capture is enabled
        let allUrls = [url];
        if (deep_capture) {
          console.log(`üîç Deep capture enabled - fetching internal links for ${url}`);
          try {
            const internalLinks = await getInternalLinksAPI(url);
            console.log(`üìÑ Found ${internalLinks.length} internal links:`);
            internalLinks.forEach((link, index) => {
              console.log(`   ${index + 1}. ${link}`);
            });
            
            allUrls = Array.from(new Set([url, ...internalLinks.slice(0, 10)])); // Limit to 10 internal links
            console.log(`üìÑ Will capture ${allUrls.length} unique URLs:`);
            allUrls.forEach((link, index) => {
              console.log(`   ${index + 1}. ${link}`);
            });
          } catch (error) {
            console.log(`‚ö†Ô∏è Failed to fetch internal links: ${error.message}`);
          }
        }

        // Take screenshots for all URLs (only if capture is true)
        const screenshotResults = [];
        if (capture) {
          for (let j = 0; j < allUrls.length; j++) {
            const screenshotUrl = allUrls[j];
            console.log(`   üì∏ Capturing: ${screenshotUrl}`);
            
            // Add 5-second delay before capturing each URL
            if (j > 0) {
              console.log(`   ‚è≥ Waiting 5 seconds before capturing next URL...`);
              await new Promise(resolve => setTimeout(resolve, 5000));
            }
            
            const screenshotResult = await takeScreenshotAPI(browser, screenshotUrl, outputDir);
            screenshotResults.push({
              url: screenshotUrl,
              success: screenshotResult.success,
              fullPage: screenshotResult.fullPageFile,
              viewport: screenshotResult.viewportFile,
              error: screenshotResult.error
            });
          }
        } else {
          console.log(`   ‚è≠Ô∏è Skipping screenshot capture (capture=false)`);
          // Add placeholder results for URLs without capturing
          allUrls.forEach(screenshotUrl => {
            screenshotResults.push({
              url: screenshotUrl,
              success: false,
              fullPage: null,
              viewport: null,
              error: 'Screenshot capture disabled'
            });
          });
        }
        
        let analysisResult = null;
        let analysisFile = null;

        // Analyze if requested (only analyze the main URL)
        if (analyze) {
          console.log(`ü§ñ Analyzing web URL: ${url}`);
          analysisResult = await analyzeUrlWithOpenAI(url, 'web');
          analysisFile = await saveAnalysisToFile(analysisResult, url, projectName, 'web');
        }

        results.push({
          url,
          projectName,
          deepCapture: deep_capture,
          totalUrls: allUrls.length,
          screenshots: screenshotResults,
          analysis: analysisResult,
          analysisFile: analysisFile,
          success: screenshotResults.some(r => r.success),
          error: screenshotResults.every(r => !r.success) ? 'All screenshots failed' : null
        });

        // Random delay between URLs (except for the last one)
        if (i < urls.length - 1) {
          const delay = getRandomDelay();
          console.log(`‚è≥ Waiting ${delay/1000} seconds before next URL...`);
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
    } finally {
      await browser.close();
    }

    res.json({
      success: true,
      message: `Processed ${urls.length} web URLs`,
      results,
      summary: {
        total: urls.length,
        successful: results.filter(r => r.success).length,
        failed: results.filter(r => !r.success).length
      }
    });

  } catch (error) {
    console.error('Web screenshots API error:', error);
    res.status(500).json({ error: error.message });
  }
});

// API 2: Figma URLs Screenshot API
app.post('/api/figma-screenshots', async (req, res) => {
  try {
    const { urls, analyze = false, capture = true } = req.body;

    if (!urls || !Array.isArray(urls) || urls.length === 0) {
      return res.status(400).json({ error: 'URLs array is required and must not be empty' });
    }

    const results = [];
    const puppeteer = require("puppeteer-extra");
    const StealthPlugin = require("puppeteer-extra-plugin-stealth");
    puppeteer.use(StealthPlugin());

    const browser = await puppeteer.launch({ headless: "new" });

    try {
      for (let i = 0; i < urls.length; i++) {
        const url = urls[i];
        console.log(`üé® Processing Figma URL ${i + 1}/${urls.length}: ${url}`);

        const projectName = extractProjectName(url, 'figma');
        const outputDir = path.join(__dirname, 'screenshots', 'figma', projectName);
        
        if (!fs.existsSync(outputDir)) {
          fs.mkdirSync(outputDir, { recursive: true });
        }

        // Take Figma screenshot (only if capture is true)
        let screenshotResult = { success: false, filePath: null, error: 'Screenshot capture disabled' };
        if (capture) {
          screenshotResult = await figmaCapture.captureFigma(url, outputDir);
        } else {
          console.log(`   ‚è≠Ô∏è Skipping Figma screenshot capture (capture=false)`);
        }
        
        let analysisResult = null;
        let analysisFile = null;

        // Analyze if requested
        if (analyze) {
          console.log(`ü§ñ Analyzing Figma URL: ${url}`);
          analysisResult = await analyzeUrlWithOpenAI(url, 'figma');
          analysisFile = await saveAnalysisToFile(analysisResult, url, projectName, 'figma');
        }

        results.push({
          url,
          projectName,
          screenshot: screenshotResult.success ? {
            file: screenshotResult.filePath
          } : null,
          analysis: analysisResult,
          analysisFile: analysisFile,
          success: screenshotResult.success,
          error: screenshotResult.error
        });

        // Random delay between URLs (except for the last one)
        if (i < urls.length - 1) {
          const delay = getRandomDelay();
          console.log(`‚è≥ Waiting ${delay/1000} seconds before next URL...`);
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
    } finally {
      await browser.close();
    }

    res.json({
      success: true,
      message: `Processed ${urls.length} Figma URLs`,
      results,
      summary: {
        total: urls.length,
        successful: results.filter(r => r.success).length,
        failed: results.filter(r => !r.success).length
      }
    });

  } catch (error) {
    console.error('Figma screenshots API error:', error);
    res.status(500).json({ error: error.message });
  }
});

// API 3: App Store URLs Screenshot API
app.post('/api/store-screenshots', async (req, res) => {
  try {
    const { urls, analyze = false, capture = true } = req.body;

    if (!urls || !Array.isArray(urls) || urls.length === 0) {
      return res.status(400).json({ error: 'URLs array is required and must not be empty' });
    }

    const results = [];

    for (let i = 0; i < urls.length; i++) {
      const url = urls[i];
      console.log(`üì± Processing store URL ${i + 1}/${urls.length}: ${url}`);

      const projectName = extractProjectName(url, 'stores');
      const outputDir = path.join(__dirname, 'screenshots', 'stores', projectName);
      
      if (!fs.existsSync(outputDir)) {
        fs.mkdirSync(outputDir, { recursive: true });
      }

              // Extract app store data (only if capture is true)
        let storeResult = { success: false, screenshots: null, info: null, error: 'Screenshot capture disabled' };
        if (capture) {
          try {
            storeResult = await appStoreExtractor.handleStoreUrl(url, outputDir);
          } catch (error) {
            storeResult = { success: false, error: error.message };
          }
        } else {
          console.log(`   ‚è≠Ô∏è Skipping store screenshot capture (capture=false)`);
        }
      
      let analysisResult = null;
      let analysisFile = null;

      // Analyze if requested
      if (analyze) {
        console.log(`ü§ñ Analyzing store URL: ${url}`);
        analysisResult = await analyzeUrlWithOpenAI(url, 'app store');
        analysisFile = await saveAnalysisToFile(analysisResult, url, projectName, 'stores');
      }

      results.push({
        url,
        projectName,
        screenshots: storeResult.success ? storeResult.screenshots : null,
        info: storeResult.success ? storeResult.info : null,
        analysis: analysisResult,
        analysisFile: analysisFile,
        success: storeResult.success,
        error: storeResult.error
      });

      // Random delay between URLs (except for the last one)
      if (i < urls.length - 1) {
        const delay = getRandomDelay();
        console.log(`‚è≥ Waiting ${delay/1000} seconds before next URL...`);
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }

    res.json({
      success: true,
      message: `Processed ${urls.length} store URLs`,
      results,
      summary: {
        total: urls.length,
        successful: results.filter(r => r.success).length,
        failed: results.filter(r => !r.success).length
      }
    });

  } catch (error) {
    console.error('Store screenshots API error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Health check endpoint
app.get('/health', (req, res) => {
  res.json({ 
    status: 'healthy', 
    timestamp: new Date().toISOString(),
    apis: ['/api/web-screenshots', '/api/figma-screenshots', '/api/store-screenshots']
  });
});

// API documentation endpoint
app.get('/api/docs', (req, res) => {
  res.json({
    apis: {
      'web-screenshots': {
        endpoint: 'POST /api/web-screenshots',
        description: 'Capture screenshots from web URLs',
        body: {
          urls: 'Array of web URLs',
          analyze: 'Boolean (optional) - Enable AI analysis',
          deep_capture: 'Boolean (optional) - Capture all internal links (up to 10)',
          capture: 'Boolean (optional) - Enable screenshot capture (default: true)'
        }
      },
      'figma-screenshots': {
        endpoint: 'POST /api/figma-screenshots',
        description: 'Capture screenshots from Figma URLs',
        body: {
          urls: 'Array of Figma URLs',
          analyze: 'Boolean (optional) - Enable AI analysis',
          capture: 'Boolean (optional) - Enable screenshot capture (default: true)'
        }
      },
      'store-screenshots': {
        endpoint: 'POST /api/store-screenshots',
        description: 'Extract screenshots and info from app store URLs',
        body: {
          urls: 'Array of app store URLs',
          analyze: 'Boolean (optional) - Enable AI analysis',
          capture: 'Boolean (optional) - Enable screenshot capture (default: true)'
        }
      }
    }
  });
});

// Serve static files
app.use('/screenshots', express.static(path.join(__dirname, 'screenshots')));

const PORT = process.env.PORT || 4000;
app.listen(PORT, () => {
  console.log(`üöÄ Portfolio Screenshot API running on http://localhost:${PORT}`);
  console.log(`üìö API Documentation: http://localhost:${PORT}/api/docs`);
  console.log(`‚ù§Ô∏è  Health Check: http://localhost:${PORT}/health`);
});
